<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"changjianfeishui.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="图层对象是Core Animation中所有操作的核心, 负责应用内容的可视化呈现. 在iOS中, 所有视图都是图层支持视图, 但在OS X中, 需要开发者为视图手动开启图层支持功能. 要使用图层支持视图, 就必须了解如何设置图层来实现想要的效果.">
<meta property="og:type" content="article">
<meta property="og:title" content="CoreAnimation编程指南翻译(三):设置图层对象">
<meta property="og:url" content="https://changjianfeishui.github.io/2019/03/04/%E8%AE%BE%E7%BD%AE%E5%9B%BE%E5%B1%82%E5%AF%B9%E8%B1%A1/index.html">
<meta property="og:site_name" content="做点有意思的事情">
<meta property="og:description" content="图层对象是Core Animation中所有操作的核心, 负责应用内容的可视化呈现. 在iOS中, 所有视图都是图层支持视图, 但在OS X中, 需要开发者为视图手动开启图层支持功能. 要使用图层支持视图, 就必须了解如何设置图层来实现想要的效果.">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CoreAnimation_guide/Art/layer_contentsgravity1_2x.png">
<meta property="og:image" content="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CoreAnimation_guide/Art/positioningmask_2x.png">
<meta property="og:image" content="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CoreAnimation_guide/Art/layer_border_background_2x.png">
<meta property="og:image" content="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CoreAnimation_guide/Art/layer_corner_radius_2x.png">
<meta property="og:image" content="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CoreAnimation_guide/Art/layer_shadows_2x.png">
<meta property="article:published_time" content="2019-03-04T10:57:14.000Z">
<meta property="article:modified_time" content="2019-03-20T03:10:30.640Z">
<meta property="article:author" content="mangox">
<meta property="article:tag" content="Core Animation">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CoreAnimation_guide/Art/layer_contentsgravity1_2x.png">

<link rel="canonical" href="https://changjianfeishui.github.io/2019/03/04/%E8%AE%BE%E7%BD%AE%E5%9B%BE%E5%B1%82%E5%AF%B9%E8%B1%A1/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>CoreAnimation编程指南翻译(三):设置图层对象 | 做点有意思的事情</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">做点有意思的事情</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">每天进步一点点</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://changjianfeishui.github.io/2019/03/04/%E8%AE%BE%E7%BD%AE%E5%9B%BE%E5%B1%82%E5%AF%B9%E8%B1%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="mangox">
      <meta itemprop="description" content="每天进步一点点">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="做点有意思的事情">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          CoreAnimation编程指南翻译(三):设置图层对象
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-03-04 18:57:14" itemprop="dateCreated datePublished" datetime="2019-03-04T18:57:14+08:00">2019-03-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-03-20 11:10:30" itemprop="dateModified" datetime="2019-03-20T11:10:30+08:00">2019-03-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a>
                </span>
            </span>

          
            <span id="/2019/03/04/%E8%AE%BE%E7%BD%AE%E5%9B%BE%E5%B1%82%E5%AF%B9%E8%B1%A1/" class="post-meta-item leancloud_visitors" data-flag-title="CoreAnimation编程指南翻译(三):设置图层对象" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/03/04/%E8%AE%BE%E7%BD%AE%E5%9B%BE%E5%B1%82%E5%AF%B9%E8%B1%A1/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/03/04/%E8%AE%BE%E7%BD%AE%E5%9B%BE%E5%B1%82%E5%AF%B9%E8%B1%A1/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>图层对象是<code>Core Animation</code>中所有操作的核心, 负责应用内容的可视化呈现. 在iOS中, 所有视图都是图层支持视图, 但在OS X中, 需要开发者为视图手动开启图层支持功能. 要使用图层支持视图, 就必须了解如何设置图层来实现想要的效果. </p>
<span id="more"></span>

<h1 id="为应用开启Core-Animation支持"><a href="#为应用开启Core-Animation支持" class="headerlink" title="为应用开启Core Animation支持"></a>为应用开启Core Animation支持</h1><p>在iOS应用中, <code>Core Animation</code>是默认开启的, 所有视图都是图层支持视图. 在OS X中需要以下步骤为应用启动<code>Core Animation</code>支持:</p>
<ul>
<li>链接<code>QuartzCore</code>框架(iOS应用只在显式调用<code>Core Animation</code>接口时才需要链接此框架).</li>
<li>通过以下步骤为一个或多个<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/appkit/nsview">NSView</a>对象开启图层支持:<ul>
<li>在nib文件中, 使用View Effects检查器开启图层支持. </li>
<li>对代码创建的视图, 调用视图的<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/appkit/nsview/1483695-wantslayer">setWantsLayer:</a>方法并确保入参为<code>YES</code>.</li>
</ul>
</li>
</ul>
<p>以上两种方法都可以在OS X中创建图层支持视图. 另外在OS X中还可以创建图层托管视图, 需要开发者手动创建和管理底层的图层对象(iOS中不能创建图层托管视图). 更多关于创建图层托管视图的信息请参阅下文. </p>
<h1 id="更改视图关联的图层对象"><a href="#更改视图关联的图层对象" class="headerlink" title="更改视图关联的图层对象"></a>更改视图关联的图层对象</h1><p>图层支持视图默认创建的<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/quartzcore/calayer">CALayer</a>对象已经可以满足大部分需求. 不过<code>Core Animation</code>还提供了丰富的图层类型, 每种图层类型都有特定的能力. 选择使用合适的图层类型可以很方便的提升性能或显示特定的内容. 比如<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/quartzcore/catiledlayer">CATiledLayer</a>可以被用来高效率的展示大图片.</p>
<h2 id="更改UIView使用的图层类型"><a href="#更改UIView使用的图层类型" class="headerlink" title="更改UIView使用的图层类型"></a>更改UIView使用的图层类型</h2><p>可以通过重写UIView类的<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/uikit/uiview/1622626-layerclass">layerClass</a>方法来返回一个指定的图层类型. 默认情况下, iOS中的视图会创建一个<code>CALayer</code>类型的图层对象, 并且使用这个图层对象作为内容的后备存储(<strong>backing store</strong>). 但在下面的情况下, 可以选择更合适的图层类: </p>
<ul>
<li>视图需要使用Metal或OpenGL ES绘制内容, 此时应该使用<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/quartzcore/cametallayer">CAMetalLayer</a>或<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/quartzcore/caeagllayer">CAEAGLLayer</a>对象,</li>
<li>有特定的图层类型可以提供更好的性能.</li>
<li>需要使用<code>Core Animation</code>封装好的图层类, 比如<code>CAEmitterLayer</code>和<code>CAReplicatorLayer</code>.</li>
</ul>
<p>如Listing 2-1所示, 改变一个视图的图层类型十分简单. 视图在展示之前, 会先调用<code>layerClass</code>方法, 然后根据其返回的图层类型创建一个图层对象. 视图的图层对象一旦被创建, 就无法再被更改.</p>
<ul>
<li><strong>Listing 2-1</strong> 更改UIView的图层类型</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+ (Class) layerClass &#123;</span><br><span class="line">   return [CAMetalLayer class];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="更改NSView使用的图层类型"><a href="#更改NSView使用的图层类型" class="headerlink" title="更改NSView使用的图层类型"></a>更改NSView使用的图层类型</h2><p>可以通过重写<code>NSView</code>类的<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/appkit/nsview/1483687-makebackinglayer">makeBackingLayer</a>方法来返回一个指定图层类型. 在该方法的实现中需要创建并返回一个图层对象. </p>
<h2 id="在OS-X中使用图层托管视图"><a href="#在OS-X中使用图层托管视图" class="headerlink" title="在OS X中使用图层托管视图"></a>在OS X中使用图层托管视图</h2><p>图层托管视图是一个<code>NSView</code>对象, 由开发者创建管理其底层的图层对象. </p>
<p>当调用<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/appkit/nsview/1483298-layer">setLayer:</a>方法并传入一个图层对象时, AppKit便不再对图层对象进行管理. 正常情况下, AppKit会负责更新图层对象, 但在图层托管时, 大部分属性都不在由AppKit维护.</p>
<p>Listing 2-2 展示了如何创建图层托管视图. 此外, 除了设置图层对象之外, 别忘了还需要调用<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/appkit/nsview/1483695-wantslayer">setWantsLayer:</a>开启视图的图层支持. </p>
<ul>
<li><strong>Listing 2-2</strong> 创建图层托管视图</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// Create myView...</span><br><span class="line"> </span><br><span class="line">[myView setWantsLayer:YES];</span><br><span class="line">CATiledLayer* hostedLayer = [CATiledLayer layer];</span><br><span class="line">[myView setLayer:hostedLayer];</span><br><span class="line"> </span><br><span class="line">// Add myView to a view hierarchy.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果选择使用图层托管, 则必须设置<code>contentsScale</code>属性, 并在合适的时机提供高分辨率的内容. 更多关于高分辨率内容和内容缩放的信息参阅下文<a href="">处理高分辨率图像</a>.</p>
<h2 id="不同图层类的使用场景"><a href="#不同图层类的使用场景" class="headerlink" title="不同图层类的使用场景"></a>不同图层类的使用场景</h2><p><code>Core Animation</code>中定义了许多不同的图层类, 每个图层类都有其适用场景. <code>CALayer</code>是所有图层类的父类, 定义了所有图层类都必须支持的行为. Table 2-1中介绍了不同图层类及其用途.</p>
<ul>
<li><strong>Table 2-2</strong> CALayer的子类及用途</li>
</ul>
<table>
<thead>
<tr>
<th align="center">Class</th>
<th align="center">使用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">CAEmitterLayer</td>
<td align="center">Used to implement a Core Animation–based particle emitter system. The emitter layer object controls the generation of the particles and their origin.</td>
</tr>
<tr>
<td align="center">CAGradientLayer</td>
<td align="center">Used to draw a color gradient that fills the shape of the layer (within the bounds of any rounded corners).</td>
</tr>
<tr>
<td align="center">CAMetalLayer</td>
<td align="center">Used to set up and vend drawable textures for rendering layer content using Metal.</td>
</tr>
<tr>
<td align="center">CAEAGLLayer&#x2F;CAOpenGLLayer</td>
<td align="center">Used to set up the backing store and context for rendering layer content using OpenGL ES (iOS) or OpenGL (OS X).</td>
</tr>
<tr>
<td align="center">CAReplicatorLayer</td>
<td align="center">Used when you want to make copies of one or more sublayers automatically. The replicator makes the copies for you and uses the properties you specify to alter the appearance or attributes of the copies.</td>
</tr>
<tr>
<td align="center">CAScrollLayer</td>
<td align="center">Used to manage a large scrollable area composed of multiple sublayers.</td>
</tr>
<tr>
<td align="center">CAShapeLayer</td>
<td align="center">Used to draw a cubic Bezier spline. Shape layers are advantageous for drawing path-based shapes because they always result in a crisp path, as opposed to a path you draw into a layer’s backing store, which would not look as good when scaled. However, the crisp results do involve rendering the shape on the main thread and caching the results.</td>
</tr>
<tr>
<td align="center">CATextLayer</td>
<td align="center">Used to render a plain or attributed string of text.</td>
</tr>
<tr>
<td align="center">CATiledLayer</td>
<td align="center">Used to manage a large image that can be divided into smaller tiles and rendered individually with support for zooming in and out of the content.</td>
</tr>
<tr>
<td align="center">CATransformLayer</td>
<td align="center">Used to render a true 3D layer hierarchy, rather than the flattened layer hierarchy implemented by other layer classes.</td>
</tr>
<tr>
<td align="center">QCCompositionLayer</td>
<td align="center">Used to render a Quartz Composer composition. (OS X only).</td>
</tr>
</tbody></table>
<h1 id="提供图层内容"><a href="#提供图层内容" class="headerlink" title="提供图层内容"></a>提供图层内容</h1><p>图层是负责管理应用内容的数据对象. 图层的内容可以理解为待展示数据的可视化位图. 有三种方式可以为这个位图提供内容: </p>
<ul>
<li>将image对象直接赋值给图层的<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/quartzcore/calayer/1410773-contents">contents</a>属性(适用于图层内容不会被频繁更改的情况).</li>
<li>设置图层delegate, 并由delegate负责绘制图层内容(适用于图层内容会周期性变化, 并且需要由外部对象提供图层内容的情况. 这里的外部对象通常是一个视图).</li>
<li>定义一个图层子类, 通过重写其绘制方法来提供内容(适用于必须自定义图层修改其基本绘图行为的情况).</li>
</ul>
<p>只有创建独立图层时才涉及到为图层提供内容. 如果应用只包含图层支持视图, 则不必用到上面的方法. 图层支持视图会以最高效的方式自动为其关联的图层提供内容。</p>
<h2 id="使用image对象提供图层内容"><a href="#使用image对象提供图层内容" class="headerlink" title="使用image对象提供图层内容"></a>使用image对象提供图层内容</h2><p>由于图层可以理解为一个管理位图的容器, 所以可以直接将一个图片赋值给图层的<code>contents</code>属性, 将其显示在屏幕上. 图层会直接使用提供的图片, 而不会创建其拷贝. 尤其是需要在多处展示同一张图片时, 这样做可以节约内存. </p>
<p>赋值给图层使用的图片必须是一个<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/coregraphics/cgimageref">CGImageRef</a>类型(OS X 10.6之后, 也可以是<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/appkit/nsimage">NSImage</a>类型). 提供的图片的分辨率必须与设备的分辨率相匹配. 对Retina设备来说, 可能还会需要调整图片的<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/quartzcore/calayer/1410746-contentsscale">contentsScale</a>属性. 更多关于高分辨率内容和内容缩放的信息参阅下文<a href="">处理高分辨率图像</a>.</p>
<h2 id="使用Delegate提供图层内容"><a href="#使用Delegate提供图层内容" class="headerlink" title="使用Delegate提供图层内容"></a>使用Delegate提供图层内容</h2><p>如果图层内容需要动态变化, 可以使用delegate对象来提供和更新内容. 在实际展示之前, 图片会调用delegate的方法获取内容: </p>
<ul>
<li>如果delegate实现了<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/quartzcore/calayerdelegate/2097261-displaylayer">displayLayer:</a>方法, 则由该方法负责创建位图并赋值给<code>contents</code>属性.</li>
<li>如果delegate实现了<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/quartzcore/calayerdelegate/2097262-drawlayer">drawLayer:inContext:</a>方法, <code>Core Animation</code>会创建一个位图, 以及一个图形上下文用于在位图中绘制内容, 然后调用该方法在图形上下文中绘制内容.</li>
</ul>
<p>delegate对象必须实现上面两种方法中的其中一种. 如果同时实现了两种方法, 则只会调用<code>displayLayer:</code>方法. </p>
<p>重写<code>displayLayer:</code>方法适用于由应用负责来加载或创建位图的情况. Listing 2-3是<code>displayLayer:</code>方法的一个简单实现. 示例代码中, delegate通过一个helper对象来加载图片, 并且根据一个内部状态值判断需要加载哪张图片.</p>
<ul>
<li><strong>Listing 2-3</strong> 直接设置图层内容</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (void)displayLayer:(CALayer *)theLayer &#123;</span><br><span class="line">    // Check the value of some state property</span><br><span class="line">    if (self.displayYesImage) &#123;</span><br><span class="line">        // Display the Yes image</span><br><span class="line">        theLayer.contents = [someHelperObject loadStateYesImage];</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        // Display the No image</span><br><span class="line">        theLayer.contents = [someHelperObject loadStateNoImage];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果不需要对图片进行预渲染, 或者不需要一个helper对象,  也可以通过<code>drawLayer:inContext:</code>方法动态绘制内容. Listing 2-4 是<code>drawLayer:inContext:</code>的一个简单实现. 示例代码中使用固定宽度和当前颜色绘制了一个简单的曲线路径.</p>
<ul>
<li>Listing 2-4 绘制图层内容</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (void)drawLayer:(CALayer *)theLayer inContext:(CGContextRef)theContext &#123;</span><br><span class="line">    CGMutablePathRef thePath = CGPathCreateMutable();</span><br><span class="line"> </span><br><span class="line">    CGPathMoveToPoint(thePath,NULL,15.0f,15.f);</span><br><span class="line">    CGPathAddCurveToPoint(thePath,</span><br><span class="line">                          NULL,</span><br><span class="line">                          15.f,250.0f,</span><br><span class="line">                          295.0f,250.0f,</span><br><span class="line">                          295.0f,15.0f);</span><br><span class="line"> </span><br><span class="line">    CGContextBeginPath(theContext);</span><br><span class="line">    CGContextAddPath(theContext, thePath);</span><br><span class="line"> </span><br><span class="line">    CGContextSetLineWidth(theContext, 5);</span><br><span class="line">    CGContextStrokePath(theContext);</span><br><span class="line"> </span><br><span class="line">    // Release the path</span><br><span class="line">    CFRelease(thePath);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对于使用自定义内容的图层支持视图, 可以重写视图的<code>drawRect:</code>方法绘制内容, 视图会自动成为其图层的delegate, 并实现所需的绘制方法. </p>
<p>在OS X 10.8及更高版本中, 通过重写视图的<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/appkit/nsview/1483461-wantsupdatelayer">wantsUpdateLayer</a>和<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/appkit/nsview/1483580-updatelayer">updateLayer</a>方法提供位图. 在<code>wantsUpdateLayer</code>返回<code>YES</code>时, <code>NSView</code>会遵循备用渲染路径. <code>updateLayer</code>方法的实现中必须将一个位图赋值给图层的<code>contents</code>属性. </p>
<h2 id="通过子类提供图层内容"><a href="#通过子类提供图层内容" class="headerlink" title="通过子类提供图层内容"></a>通过子类提供图层内容</h2><p>使用自定义图层类型时, 可以通过重写图层的绘制方法来进行内容绘制. 虽然这种由图层对象自身生成内容的情况并不多见, 但是图层确实能直接管理内容的绘制. 比如<code>CATiledLayer</code>类通过将一张大图分解为多个小图来进行管理和独立渲染. 这是因为只有图层才知道在指定的时刻将要渲染哪些独立的小图. </p>
<p>当使用图层子类时, 可以选择使用下面的方法之一进行内容绘制:</p>
<ul>
<li>重写图层的<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/quartzcore/calayer/1410926-display">display</a>方法, 并在方法中设置图层的<code>contents</code>属性.</li>
<li>重写图层的<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/quartzcore/calayer/1410757-draw">drawInContext:</a>方法, 在方法提供的图形上下文中进行绘制.</li>
</ul>
<p>具体选择哪种方法取决于对绘制过程的控制程度. <code>display</code>方法是图层绘制的入口点, 重写该方法意味着将由开发者完成整个的绘制过程, 也就是说由开发者负责创建<code>CGImageRef</code>对象, 并赋值给<code>contents</code>属性. 如果只需要绘制内容(或者让图层管理绘制操作), 可以重写<code>drawInContext:</code>方法, 这样图层会负责创建后备存储(backing store).</p>
<h2 id="调整图层内容"><a href="#调整图层内容" class="headerlink" title="调整图层内容"></a>调整图层内容</h2><p>当把一个位图赋值给图层的<code>contents</code>属性时, 图层的<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/quartzcore/calayer/1410872-contentsgravity">contentsGravity</a>属性决定了如何操作图片以适应图层的内容边界. 默认情况下, 如果图片比当前边界更大或者更小, 图层会缩放图片来适应当前边界. 所以如果图层的宽高比与图片宽高比不一致, 可能会导致图片失真. 此时可以使用<code>contentsGravity</code>属性进行调整.</p>
<p><code>contentsGravity</code>属性可用的常量参数可以分为两类: </p>
<ul>
<li>基于位置的常量参数可以将图片固定在指定的边角, 图片不会失真.</li>
<li>基于缩放的常量参数可以对图片进行拉伸, 使用其中的一些参数可能导致图片的宽高比可能会发生变化.</li>
</ul>
<p>Figure 2-1 展示了设置基于位置的常量参数对图片的影响. 除了<code>kCAGravityCenter</code>常量会使图片居中之外, 其他常量都会将图片固定到某个边或角. 所有这些常量参数都不会导致图片失真, 图片将始终以原始大小进行渲染. 如果图片尺寸大于边界尺寸, 部分图片可能会被裁减, 如果图片尺寸小于边界尺寸, 如果设置了图层的背景色, 那么图层的一部分将展示图层的背景色.</p>
<ul>
<li><strong>Figure 2-1</strong> 基于位置的常量参数</li>
</ul>
<p><img src="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CoreAnimation_guide/Art/layer_contentsgravity1_2x.png" alt="基于位置的常量参数"></p>
<p>Figure 2-2 展示了设置基于缩放的常量参数对图片的影响. 如果图片尺寸与边界尺寸不一致, 所有这些常量参数都会缩放图片, 区别在于如果处理图片的宽高比. 默认情况下, 图层的<code>contentsGravity</code>属性被设置为<code>kCAGravityResize</code>, 只有这个常量参数会改变图片的原始宽高比. </p>
<ul>
<li><strong>Figure 2-2</strong> 基于缩放的常量参数</li>
</ul>
<p><img src="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CoreAnimation_guide/Art/positioningmask_2x.png" alt="基于缩放的常量参数"></p>
<h2 id="处理高分辨率图像"><a href="#处理高分辨率图像" class="headerlink" title="处理高分辨率图像"></a>处理高分辨率图像</h2><p>图层并不知道底层设备的屏幕分辨率, 只是存储一个指向位图的指针, 并以最佳的形式展示位图. 设置<code>contents</code>时, 还必须同时设置<code>contentsScale</code>属性, 告知<code>Core Animation</code>所使用图片的分辨率. <code>contentsScale</code>属性默认值为1.0, 适用于非Retina屏幕. 要在Retina屏幕上显示, 需要将<code>contentsScale</code>属性设置为2.0.</p>
<p>只有手动设置<code>contents</code>时才需要同时设置<code>contentsScale</code>. UIKit和AppKit中的图层支持视图会自动根据屏幕分辨率和视图内容自动设置图片的缩放比例.</p>
<h1 id="调整图层的视觉样式和外观"><a href="#调整图层的视觉样式和外观" class="headerlink" title="调整图层的视觉样式和外观"></a>调整图层的视觉样式和外观</h1><p>图层对象还内置了一些视觉装饰属性, 比如边框和背景颜色, 用于对图层内容的补充. 这些视觉装饰只需要设置图层的对应属性, 然后由<code>Core Animation</code>完成必要的渲染或动画. 更多关于视觉装饰相关的信息, 参阅<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CoreAnimation_guide/LayerStyleProperties/LayerStyleProperties.html#//apple_ref/doc/uid/TP40004514-CH10-SW1">图层样式动画</a>.</p>
<h2 id="图层的背景色和边框"><a href="#图层的背景色和边框" class="headerlink" title="图层的背景色和边框"></a>图层的背景色和边框</h2><p>除了基于位图内容之外, 图层还可以显示背景色和边框. 如Figure 2-3所示, 背景色在图层图像内容的下一层进行渲染, 边框则在图层图像内容的上一层进行渲染. 如果图层包含子图层, 子图层也显示在父图层边框的下面. 由于背景色渲染在图像内容之下, 所以背景色会穿透图像的透明部分. </p>
<ul>
<li><strong>Figure 2-3</strong> 图层的背景色和边框</li>
</ul>
<p><img src="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CoreAnimation_guide/Art/layer_border_background_2x.png" alt="图层的背景色和边框"></p>
<p>Listing 2-5 展示了设置背景色和边框的代码. 这些属性都是可动画的.</p>
<ul>
<li><strong>Listing 2-5</strong> 设置图层的背景色和边框</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">myLayer.backgroundColor = [NSColor greenColor].CGColor;</span><br><span class="line">myLayer.borderColor = [NSColor blackColor].CGColor;</span><br><span class="line">myLayer.borderWidth = 3.0;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<blockquote>
<p>注意: 图层的背景色支持任意类型的颜色, 包括具有透明度的颜色或是模式图像(pattern image). 当使用模式图像时, <code>Core Graphics</code>会使用标准坐标系渲染图像. 标准坐标系与iOS默认坐标系不同, 因此, iOS上渲染的图像默认会上下颠倒, 除非翻转坐标系.</p>
</blockquote>
<p>如果给图层设置了一个不透明的背景色, 可以考虑将图层的<code>opaque</code>属性设置为<code>YES</code>. 这样在屏幕进行图层合成时可以提升性能, 并且无需图层的后备存储来管理alpha通道. 但是当图层的圆角半径不为0时, 就不能将图片标记为不透明. </p>
<h2 id="图层的圆角半径"><a href="#图层的圆角半径" class="headerlink" title="图层的圆角半径"></a>图层的圆角半径</h2><p>可以设置图层的圆角半径来实现圆角矩形的效果. 圆角半径是图层视觉装饰属性之一, 可以遮挡图层边界矩形的部分角, 如Figure 2-4所示. 由于使用了透明蒙版, 所以圆角半径不会影响图层的<code>contents</code>属性中设置的图像, 除非图层的<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/quartzcore/calayer/1410896-maskstobounds">masksToBounds</a>被设置为<code>YES</code>. 但是圆角半径始终会影响图层的背景色和边框. </p>
<p>要设置图层的圆角半径, 需要设置图层的<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/quartzcore/calayer/1410818-cornerradius">cornerRadius</a>属性. 半径值以点为单位, 并且同时应用到图层的四个角. </p>
<ul>
<li><strong>Figure 2-4</strong> 图层的圆角半径</li>
</ul>
<p><img src="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CoreAnimation_guide/Art/layer_corner_radius_2x.png" alt="图层的圆角半径"></p>
<h2 id="图层的阴影"><a href="#图层的阴影" class="headerlink" title="图层的阴影"></a>图层的阴影</h2><p><code>CALayer</code>类包含了配置图层阴影效果的属性, 可以分别设置阴影的颜色, 相对位置, 不透明度以及形状. 阴影看起来好像浮在图层内容之上, 从而增加了图层的深度. 图层阴影也是一种十分有用的视觉装饰属性. </p>
<p>阴影默认的不透明度为0, 即隐藏阴影.  如果阴影的不透明度被设置为非0值, <code>Core Animation</code>就会绘制阴影. 阴影处于图层内容的下一层, 所以可能还需要更改阴影的偏移量才能看到阴影.  需要注意的是, 阴影的偏移量设置使用的是设备的坐标系, 这在iOS 和OS X上有所区别. Figure 2-5展示了带阴影的图层, 阴影向下延展到图层右侧. 在iOS中, 这需要设置y轴方向为正值, 在OS X中, 这需要设置y轴方向为负值. </p>
<ul>
<li><strong>Figure 2-4</strong> 图层的阴影</li>
</ul>
<p><img src="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CoreAnimation_guide/Art/layer_shadows_2x.png" alt="图层的阴影"></p>
<p>当给图层添加阴影时, 阴影实际上是图层内容的一部分, 并且会延展到图层边界之外. 所以如果设置了<code>masksToBounds</code>属性为<code>YES</code>, 那么阴影也会被裁减. 如果图层包含了透明内容, 图层正下方的阴影仍然可见, 但超出图层的阴影不可见. 如果既想使用阴影, 也想使用蒙版,  可以考虑使用两个图层进行嵌套, 将蒙版应用于显示内容的图层, 然后将这个图层嵌入到另一个同样大小并且设置了阴影的图层之中. </p>
<p>更多设置图层阴影的示例, 请参阅<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CoreAnimation_guide/LayerStyleProperties/LayerStyleProperties.html#//apple_ref/doc/uid/TP40004514-CH10-SW18">阴影属性</a>. </p>
<h2 id="为图层添加视觉效果-OS-X"><a href="#为图层添加视觉效果-OS-X" class="headerlink" title="为图层添加视觉效果(OS X)"></a>为图层添加视觉效果(OS X)</h2><p>在iOS应用中, 可以直接在图层内容上使用<code>Core Image</code>滤镜. 可以通过滤镜实现图像模糊, 锐化, 颜色修改以及更多其他操作. 由于滤镜直接作用于底层硬件, 所以可以十分迅速和平滑的进行渲染. </p>
<p>注意: 在iOS中不能给图层对象添加滤镜. </p>
<p>给定一个图层, 滤镜可以同时应用到图层的前景内容和背景内容. 前景内容包含图层本身的所有内容, <code>contents</code>图像, 背景色, 边框以及子图层. 背景内容是直接位于图层内容之下的内容, 但不包括图层本身. 大多数图层的背景内容是其直接父图层, 背景内容可能会被前景内容部分或完全遮挡. 比如想要将用户注意力聚焦在前景内容时, 可以对背景内容使用模糊滤镜. </p>
<p>可以将<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/coreimage/cifilter">CIFilter</a>对象赋值给图层的下列属性: </p>
<ul>
<li><a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/quartzcore/calayer/1410901-filters">filters</a>属性包含一个滤镜数组, 仅影响图层的前景内容.</li>
<li><a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/quartzcore/calayer/1410827-backgroundfilters">backgroundFilters</a>属性包含一个滤镜数组, 仅影响图层的背景内容.</li>
<li><a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/quartzcore/calayer/1410748-compositingfilter">compositingFilter</a>属性指定前景内容和背景内容如何合成在一起.</li>
</ul>
<p>在将滤镜添加到图层之前, 最好先对滤镜的参数进行配置. 因为一旦添加到图层后, 就不能再修改<code>CIFilter</code>对象, 但是可以使用<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/objectivec/nsobject/1418139-setvalue">setValue:forKeyPath:</a>方法修改滤镜的值.</p>
<p>Listing 2-6 展示了如何创建添加一个收缩失真滤镜(凹面镜)并添加到图层上. 注意并不需要给滤镜指定图像, 滤镜会自动使用图层的内容图像. </p>
<ul>
<li><strong>Listing 2-6</strong> 给图层添加滤镜</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CIFilter* aFilter = [CIFilter filterWithName:@&quot;CIPinchDistortion&quot;];</span><br><span class="line">[aFilter setValue:[NSNumber numberWithFloat:500.0] forKey:@&quot;inputRadius&quot;];</span><br><span class="line">[aFilter setValue:[NSNumber numberWithFloat:1.25] forKey:@&quot;inputScale&quot;];</span><br><span class="line">[aFilter setValue:[CIVector vectorWithX:250.0 Y:150.0] forKey:@&quot;inputCenter&quot;];</span><br><span class="line"> </span><br><span class="line">myLayer.filters = [NSArray arrayWithObject:aFilter];</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>更多关于滤镜的信息, 请参阅<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/GraphicsImaging/Reference/CoreImageFilterReference/index.html#//apple_ref/doc/uid/TP40004346">Core Image Filter Reference</a>.</p>
<h1 id="图层重绘策略对性能的影响-OS-X"><a href="#图层重绘策略对性能的影响-OS-X" class="headerlink" title="图层重绘策略对性能的影响(OS X)"></a>图层重绘策略对性能的影响(OS X)</h1><p>在OS X中, 图层支持视图可以使用不同的重绘策略来更新内容. 由于AppKit和<code>Core Animation</code>中的绘图模型存在差异, 这些重绘策略可以更方便的将旧代码迁徙到<code>Core Animation</code>. 可以为每个视图配置不同的重绘策略, 以达到最佳性能. </p>
<p>可以使用视图的<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/appkit/nsview/1483514-layercontentsredrawpolicy">layerContentsRedrawPolicy</a>方法获得当前视图关联图层的重绘策略, 可以使用<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/appkit/nsview/1483514-layercontentsredrawpolicy">setLayerContentsRedrawPolicy:</a>设置重绘策略. 为了兼容传统绘图模型, AppKit默认将重绘策略设置为<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/appkit/nsview/layercontentsredrawpolicy/duringviewresize">NSViewLayerContentsRedrawDuringViewResize</a>. 可以根据需要选择使用Table 2-2中的重绘策略.</p>
<ul>
<li><strong>Table 2-2</strong> OS X支持的重绘策略</li>
</ul>
<table>
<thead>
<tr>
<th align="center">Policy</th>
<th align="center">Usage</th>
</tr>
</thead>
<tbody><tr>
<td align="center">NSViewLayerContentsRedrawOnSetNeedsDisplay</td>
<td align="center">This is the recommended policy. With this policy, view geometry changes do not automatically cause the view to update its layer’s contents. Instead, the layer’s existing contents are stretched and manipulated to facilitate the geometry changes. To force the view to redraw itself and update the layer’s contents, you must explicitly call the view’s setNeedsDisplay: method. This policy most closely represents the standard behavior for Core Animation layers. However, it is not the default policy and must be set explicitly.</td>
</tr>
<tr>
<td align="center">NSViewLayerContentsRedrawDuringViewResize</td>
<td align="center">This is the default redraw policy. This policy maintains maximum compatibility with traditional AppKit drawing by recaching the layer’s contents whenever the view’s geometry changes. This behavior results in the view’s drawRect: method being called multiple times on your app’s main thread during the resize operation.</td>
</tr>
<tr>
<td align="center">NSViewLayerContentsRedrawBeforeViewResize</td>
<td align="center">With this policy, AppKit draws the layer at its final size prior to any resize operations and caches that bitmap. The resize operation uses the cached bitmap as the starting image, scaling it to fit the old bounds rectangle. It then animates the bitmap to its final size. This behavior can cause the view’s contents to appear stretched or distorted at the beginning of an animation and is better in situations where the initial appearance is not important or not noticeable.</td>
</tr>
<tr>
<td align="center">NSViewLayerContentsRedrawNever</td>
<td align="center">With this policy, AppKit does not update the layer at all, even when you call the setNeedsDisplay: method. This policy is most appropriate for views whose contents never change and where the size of the view changes infrequently if at all. For example, you might use this for views that display fixed-size content or background elements.</td>
</tr>
</tbody></table>
<p>视图的重绘策略在OS X 10.6中引入, 现在建议给视图设置合适的重绘策略, 而不是另外创建独立图层来展示不需要重绘的部分. </p>
<h1 id="图层的自定义属性"><a href="#图层的自定义属性" class="headerlink" title="图层的自定义属性"></a>图层的自定义属性</h1><p><a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/quartzcore/caanimation">CAAnimation</a>和<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/quartzcore/calayer">CALayer</a>支持通过KVC扩充自定义属性. 可以通过健值对的形式给图层添加自定义数据. 甚至可以将操作与自定义属性关联, 在属性更改时, 就能自动执行动画. </p>
<p>更多关于自定义属性的信息, 请参阅<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CoreAnimation_guide/Key-ValueCodingExtensions/Key-ValueCodingExtensions.html#//apple_ref/doc/uid/TP40004514-CH12-SW3">Key-Value Coding Compliant Container Classes</a>.<br>更多关于给图层添加操作的信息, 请参阅<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CoreAnimation_guide/ReactingtoLayerChanges/ReactingtoLayerChanges.html#//apple_ref/doc/uid/TP40004514-CH7-SW1">Changing a Layer’s Default Behavior</a>.</p>
<h1 id="打印图层内容"><a href="#打印图层内容" class="headerlink" title="打印图层内容"></a>打印图层内容</h1><p>打印期间, 图层会重绘内容以适应打印环境. <code>Core Animation</code>在屏幕渲染时依赖于缓存的位图, 但在打印时会重绘内容. 如果图层支持视图使用了<code>drawRect:</code>方法提供内容, <code>Core Animation</code>会再次调用该方法生成要打印的内容. </p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Core-Animation/" rel="tag"># Core Animation</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/03/02/Core%20Animation%E5%9F%BA%E7%A1%80/" rel="prev" title="CoreAnimation编程指南翻译(二):Core Animation基础">
      <i class="fa fa-chevron-left"></i> CoreAnimation编程指南翻译(二):Core Animation基础
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/03/07/%E5%9B%BE%E5%B1%82%E5%8A%A8%E7%94%BB/" rel="next" title="CoreAnimation编程指南翻译(四):图层动画">
      CoreAnimation编程指南翻译(四):图层动画 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%BA%E5%BA%94%E7%94%A8%E5%BC%80%E5%90%AFCore-Animation%E6%94%AF%E6%8C%81"><span class="nav-number">1.</span> <span class="nav-text">为应用开启Core Animation支持</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9B%B4%E6%94%B9%E8%A7%86%E5%9B%BE%E5%85%B3%E8%81%94%E7%9A%84%E5%9B%BE%E5%B1%82%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.</span> <span class="nav-text">更改视图关联的图层对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9B%B4%E6%94%B9UIView%E4%BD%BF%E7%94%A8%E7%9A%84%E5%9B%BE%E5%B1%82%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.1.</span> <span class="nav-text">更改UIView使用的图层类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9B%B4%E6%94%B9NSView%E4%BD%BF%E7%94%A8%E7%9A%84%E5%9B%BE%E5%B1%82%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.2.</span> <span class="nav-text">更改NSView使用的图层类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8OS-X%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%9B%BE%E5%B1%82%E6%89%98%E7%AE%A1%E8%A7%86%E5%9B%BE"><span class="nav-number">2.3.</span> <span class="nav-text">在OS X中使用图层托管视图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8D%E5%90%8C%E5%9B%BE%E5%B1%82%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">2.4.</span> <span class="nav-text">不同图层类的使用场景</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8F%90%E4%BE%9B%E5%9B%BE%E5%B1%82%E5%86%85%E5%AE%B9"><span class="nav-number">3.</span> <span class="nav-text">提供图层内容</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8image%E5%AF%B9%E8%B1%A1%E6%8F%90%E4%BE%9B%E5%9B%BE%E5%B1%82%E5%86%85%E5%AE%B9"><span class="nav-number">3.1.</span> <span class="nav-text">使用image对象提供图层内容</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Delegate%E6%8F%90%E4%BE%9B%E5%9B%BE%E5%B1%82%E5%86%85%E5%AE%B9"><span class="nav-number">3.2.</span> <span class="nav-text">使用Delegate提供图层内容</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E5%AD%90%E7%B1%BB%E6%8F%90%E4%BE%9B%E5%9B%BE%E5%B1%82%E5%86%85%E5%AE%B9"><span class="nav-number">3.3.</span> <span class="nav-text">通过子类提供图层内容</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%83%E6%95%B4%E5%9B%BE%E5%B1%82%E5%86%85%E5%AE%B9"><span class="nav-number">3.4.</span> <span class="nav-text">调整图层内容</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E9%AB%98%E5%88%86%E8%BE%A8%E7%8E%87%E5%9B%BE%E5%83%8F"><span class="nav-number">3.5.</span> <span class="nav-text">处理高分辨率图像</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%B0%83%E6%95%B4%E5%9B%BE%E5%B1%82%E7%9A%84%E8%A7%86%E8%A7%89%E6%A0%B7%E5%BC%8F%E5%92%8C%E5%A4%96%E8%A7%82"><span class="nav-number">4.</span> <span class="nav-text">调整图层的视觉样式和外观</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%BE%E5%B1%82%E7%9A%84%E8%83%8C%E6%99%AF%E8%89%B2%E5%92%8C%E8%BE%B9%E6%A1%86"><span class="nav-number">4.1.</span> <span class="nav-text">图层的背景色和边框</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%BE%E5%B1%82%E7%9A%84%E5%9C%86%E8%A7%92%E5%8D%8A%E5%BE%84"><span class="nav-number">4.2.</span> <span class="nav-text">图层的圆角半径</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%BE%E5%B1%82%E7%9A%84%E9%98%B4%E5%BD%B1"><span class="nav-number">4.3.</span> <span class="nav-text">图层的阴影</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E5%9B%BE%E5%B1%82%E6%B7%BB%E5%8A%A0%E8%A7%86%E8%A7%89%E6%95%88%E6%9E%9C-OS-X"><span class="nav-number">4.4.</span> <span class="nav-text">为图层添加视觉效果(OS X)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%BE%E5%B1%82%E9%87%8D%E7%BB%98%E7%AD%96%E7%95%A5%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D-OS-X"><span class="nav-number">5.</span> <span class="nav-text">图层重绘策略对性能的影响(OS X)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%BE%E5%B1%82%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7"><span class="nav-number">6.</span> <span class="nav-text">图层的自定义属性</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%89%93%E5%8D%B0%E5%9B%BE%E5%B1%82%E5%86%85%E5%AE%B9"><span class="nav-number">7.</span> <span class="nav-text">打印图层内容</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">mangox</p>
  <div class="site-description" itemprop="description">每天进步一点点</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">131</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">35</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/changjianfeishui" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;changjianfeishui" rel="noopener" target="_blank"><i class="fa fa-link fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">mangox</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'Hl5bOvNBmh6xqvMEjzRRWMIP-gzGzoHsz',
      appKey     : '3n3m7ANssYrw0VgxYu87kQEL',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
